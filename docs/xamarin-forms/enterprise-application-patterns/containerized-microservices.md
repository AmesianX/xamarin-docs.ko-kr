---
title: 컨테이너 화 된 Microservices
ms.prod: xamarin
ms.assetid: 5872ad92-04e0-4f1a-9691-79d5602f5683
ms.technology: xamarin-forms
author: davidbritch
ms.author: dabritch
ms.date: 08/07/2017
ms.openlocfilehash: 461a1310ff430c16e49fa0ed6037a77b1302f769
ms.sourcegitcommit: 945df041e2180cb20af08b83cc703ecd1aedc6b0
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 04/04/2018
---
# <a name="containerized-microservices"></a>컨테이너 화 된 Microservices

클라이언트-서버 응용 프로그램을 개발 하면 각 계층에서 특정 기술을 사용 하는 계층화 된 응용 프로그램을 구축 하기 위해 노력 되었습니다. 이러한 응용 프로그램은 일반적으로 이라고 *모놀리식* 미리 최대 처리량에 대 한 확장 된 하드웨어에 패키지 된 응용 프로그램 및 됩니다. 이 개발 방법의 주요 단점은 개별 구성 요소는 쉽게 확장할 수 없습니다, 각 계층 내의 구성 요소와 테스트 비용 간의 긴밀 하 게 결합 됩니다. 간단한 업데이트를 가질 수 있습니다는 계층의 나머지 부분에 예상치 못한 영향 및 응용 프로그램 구성 요소에 대 한 변경에 해당 전체 계층을 다시 테스트 하 고 다시 배포할 필요 합니다.

특히 관련 된 클라우드에의 보존 기간에 개별 구성 요소는 쉽게 사용할 수 없습니다 크기가 조정 됩니다. 모놀리식 응용 프로그램 도메인 특정 기능을 포함 하 고 일반적으로 프런트 엔드, 비즈니스 논리 및 데이터 저장소와 같은 기능 계층으로 나눕니다. 그림 8-1을 보여 주는 것 처럼 여러 컴퓨터에 전체 응용 프로그램을 복제 하 여 단일 응용 프로그램 크기가 조정 됩니다.

![](containerized-microservices-images/monolithicapp.png "단일 응용 프로그램 크기 조정 방식")

**그림 8-1**: 확장 방식을 사용 하는 단일 응용 프로그램

## <a name="microservices"></a>Microservices

Microservices 응용 프로그램 개발 및 배포는 다른 접근 방식을, 민첩성, 배율 및 최신 클라우드 응용 프로그램의 안정성 요구 사항에는 적합 한 방법을 제공 합니다. 응용 프로그램의 전체 기능을 제공 하기 위해 함께 작동 하는 독립 구성 요소는 microservices 응용 프로그램 분해 됩니다. 용어 마이크로 서비스를 각 마이크로 서비스는 단일 함수를 구현 하도록 응용 프로그램 서비스 만큼 작지 않아서 독립 우려 사항에 맞게 구성 되어야 하는 강조 합니다. 또한 각 마이크로 서비스는 잘 정의 된 계약에 다른 microservices 통신 하 고 데이터를 공유할 수 있도록 합니다. 쇼핑 카트를 포함 하 고 처리 재고, 하위 시스템 및 지불 처리를 구매 하는 microservices의 대표적인 예입니다.

Microservices 규모를 확장할 개별적으로 함께 확장 되는 모놀리식의 거 대 한 응용 프로그램에 비해 합니다. 즉, 불필요 하 게 스케일 아웃 응용 프로그램의 다른 영역 보다 더 많은 처리 전원 또는 네트워크 대역폭 요구를 지원 하기 위해 필요로 하는 특정 기능 영역에서이 확장 될 수 있습니다. 그림 8-2에는이 방법을, 여기서 microservices 배포 되 고 독립적으로 확장을 보여 줍니다 컴퓨터에서 서비스의 인스턴스를 만드는 합니다.

![](containerized-microservices-images/microservicesapp.png "Microservices 응용 프로그램 크기 조정 방식")

**그림 8-2**: Microservices 응용 프로그램 확장 방식을 사용

마이크로 서비스 확장 거의 즉시 로드 변화에 맞게 응용 프로그램 허용 될 수 있습니다. 예를 들어 응용 프로그램의 웹 기능에는 단일 마이크로 서비스 추가 들어오는 트래픽을 처리 하도록 확장 해야 하는 응용 프로그램에서 유일한 마이크로 서비스를 수 있습니다.

응용 프로그램의 확장성에 대 한 클래식 모델은 영구 데이터를 저장할 공유 외부 데이터 저장소 인 부하 분산, 상태 비저장 계층이입니다. 상태 저장 microservices 일반적으로 배치 되는 서버에 로컬로 저장가 영구 데이터를 관리, 네트워크의 오버 헤드를 방지 하기 위해 액세스 및의 복잡성 교차 서비스 작업입니다. 그러면 데이터의 가능한 가장 빠른 처리가 있으며 캐싱 시스템에 대 한 필요성을 제거할 수 있습니다. 또한 확장 가능한 상태 저장 microservices는 일반적으로 단일 서버를 지원할 수 데이터 크기와 전송 처리량을 관리 하는 인스턴스 간에 데이터를 분할 합니다.

또한 Microservices 독립 업데이트를 지원합니다. Microservices 간의 느슨한 결합이 응용 프로그램을 신속 하 고 신뢰할 수 발전을 제공합니다. 독립적으로 분산 된 특성을 단일 마이크로 서비스 인스턴스의의 하위 집합만 지정된 된 시간에 업데이트할 됩니다 있는 롤링 업데이트를 지원 합니다. 따라서 문제가 감지 되 면 버그가 있는 업데이트 수 롤백할 수, 구성 또는 잘못 된 코드에 모든 인스턴스가 업데이트 전에. 마찬가지로 microservices 일반적으로 사용 하 여 스키마 버전 관리 클라이언트 업데이트를 적용할 때, 어떤 마이크로 서비스에 관계 없이 인스턴스가 통신할와 일관 된 버전을 볼 수 있도록 합니다.

따라서, 마이크로 서비스 응용 프로그램 모놀리식 응용 프로그램에 비해 다양 한 혜택을 해야합니다.

-   각 마이크로 서비스를 상대적으로 작은 쉽게 관리 및 발전시키 수 있습니다.
-   각 마이크로 서비스를 개발 하 고 다른 서비스와 독립적으로 배포 될 수 있습니다.
-   각 마이크로 서비스 수 확장 독립적으로 합니다. 예를 들어 카탈로그 서비스 또는 시장 바구니 서비스 확장을 정렬 하는 서비스 보다 더 되도록 해야 합니다. 따라서 생성 된 인프라 수평 확장 하는 경우 리소스를 보다 효율적으로 사용 합니다.
-   각 마이크로 서비스는 모든 문제를 격리합니다. 예를 들어 서비스에서 문제가 발생 하는 경우만 해당 서비스를 영향입니다. 다른 서비스 계속 요청을 처리할 수 있습니다.
-   각 마이크로 서비스에는 최신 기술을 사용할 수 있습니다. Microservices 자치 및 실행-함께 이기 때문에 최신 기술 및 프레임 워크 용도 강제로 모놀리식 응용 프로그램에서 사용할 수 있는 이전 프레임 워크를 사용 하는 대신 합니다.

그러나 마이크로 서비스 기반 솔루션에 잠재적인 단점이 있습니다.

-   Microservices로 응용 프로그램을 분할 하는 방법을 선택 하기 어려울 수 있습니다, 각 마이크로 서비스에 완전히 자치, 해당 데이터 원본에 대 한 책임을 포함 하 여 끝에 있습니다.
-   개발자는 응용 프로그램에 복잡성과 대기 시간을 추가 하는 서비스 통신을 구현 해야 합니다.
-   일반적으로 여러 microservices 간의 원자성 트랜잭션을 작업이 불가능 한 경우도 있습니다. 따라서 비즈니스 요구 사항을 microservices 간의 결과적 일관성을 도입 해야 합니다.
-   프로덕션 환경에서 배포 하 고 다양 한 독립 서비스의 손상 된 시스템 관리에 작업의 복잡성이 있습니다.
-   직접 클라이언트 마이크로 서비스 통신 microservices 계약 리팩터링 어려울 수 있습니다. 예를 들어 시간이 지남에 따라 시스템 서비스를 분할 방법을 변경 해야 할 수 있습니다. 단일 서비스 두 개 이상의 서비스를 분할할 수 있습니다 및 두 개의 서비스 병합할 수 있습니다. 클라이언트가 microservices와 직접 통신 하는 경우이 리팩터링 작업 호환성 클라이언트 앱을 손상 될 수 있습니다.

## <a name="containerization"></a>컨테이너화

컨테이너 화 되는 응용 프로그램 및 종속성을 해당 환경 구성으로 배포 매니페스트 파일 추상화는 해당 버전이 지정 된 집합과 함께 한 단위로 테스트 컨테이너 이미지로 패키지 된 소프트웨어 개발 하는 방식 및 호스트 운영 체제에 배포합니다.

컨테이너는 격리 된, 리소스 제어 되며 이식 가능한 운영 환경, 응용 프로그램 호스트 중 다른 컨테이너의 리소스를 건드리지 않고 간단히 실행할 수 있는 합니다. 따라서 컨테이너 찾아서 새로 설치한 물리적 컴퓨터나 가상 컴퓨터 처럼 작동 합니다.

그림 8-3을 보여 주는 것 처럼 컨테이너와 가상 컴퓨터 간의 많은 공통점이 있습니다.

![](containerized-microservices-images/containersvsvirtualmachines.png "Microservices 응용 프로그램 크기 조정 방식")

**그림 8-3**: 가상 컴퓨터 및 컨테이너의 비교

컨테이너는 운영 체제를 실행 파일 시스템에 있으며을 마치는 물리적 컴퓨터 또는 가상 컴퓨터 네트워크를 통해 액세스할 수 있습니다. 그러나 기술 및 컨테이너에 의해 사용 되는 개념은 가상 컴퓨터와 매우 다릅니다. 가상 컴퓨터는 응용 프로그램, 필요한 종속성 및 전체 게스트 운영 체제를 포함 합니다. 컨테이너 응용 프로그램 및 해당 종속성을 포함 하지만 운영 체제 (외에도 Hyper-v 컨테이너 컨테이너 당는 특수 가상 컴퓨터 환경에서 실행 하는) 호스트 운영 체제에서 격리 프로세스로 실행 중인 다른 컨테이너와 공유 합니다. 따라서 컨테이너 리소스를 공유 하 고 일반적으로 가상 컴퓨터 보다 더 적은 리소스가 필요 합니다.

컨테이너 지향 개발 및 배포 방법의 장점은에서 일관 되지 않은 환경 설정 및 함께 제공 하는 문제를 발생 시킨 문제를 대부분 제거는입니다. 또한 다음 필요에 따라 새 컨테이너를 인스턴스 여 하는 빠른 응용 프로그램 확장 기능을 허용 하는 컨테이너입니다.

만들기 및 컨테이너를 사용 하는 경우 주요 개념입니다.

-   컨테이너 호스트: 물리적 컴퓨터 또는 가상 컴퓨터 호스트 컨테이너를 구성 합니다. 컨테이너 호스트는 하나 이상의 컨테이너를 실행 합니다.
-   컨테이너 이미지: 이미지, 서로 위에 쌓입니다 계층화 된 파일 시스템의 공용 구조체 구성 되며는 컨테이너의 기초 합니다. 이미지 상태 없고 다양 한 환경에 배포 하는 변경 되지 않습니다.
-   컨테이너: 컨테이너 이미지의 런타임 인스턴스는.
-   컨테이너 OS 이미지: 컨테이너 이미지에서 배포 됩니다. 컨테이너 운영 체제 이미지는 컨테이너를 구성 하는 잠재적으로 많은 이미지 계층에서 첫 번째 계층입니다. 컨테이너는 운영 체제는 변경할 수 및 수정할 수 없습니다.
-   컨테이너 리포지토리: 컨테이너 이미지를 만들 때마다 이미지와 그 종속성에에서 저장 됩니다는 로컬 저장소. 이러한 이미지는 컨테이너 호스트에서 여러 번 재사용할 수 있습니다. 컨테이너 이미지도 저장할 수 있습니다, 공개 또는 개인 레지스트리 ()에 같은 [Docker 허브](https://hub.docker.com/)서로 다른 컨테이너 호스트에 걸쳐 사용할 수 있도록 합니다.

기업 응용 프로그램 기반 마이크로 서비스를 구현 하 고 Docker 대부분 소프트웨어 플랫폼 및 클라우드 공급 업체에서 채택 하는 표준 컨테이너 구현 되었습니다 컨테이너를 채택 점점 더 됩니다.

EShopOnContainers 참조 응용 프로그램 그림 8-4와 같이 4 개의 컨테이너 화 된 백 엔드 microservices 호스트할 Docker를 사용 합니다.

![](containerized-microservices-images/microservicesarchitecture.png "eShopOnContainers 응용 프로그램 백 엔드 microservices 참조")

**그림 8-4**: eShopOnContainers 응용 프로그램 백 엔드 microservices 참조

참조 응용 프로그램에서 백 엔드 서비스의 아키텍처는 공동 microservices 및 컨테이너의 형태로 여러 자치 하위 시스템으로 분해 됩니다. 단일 영역 기능을 제공 하는 각 마이크로 서비스: id 서비스, 카탈로그 서비스, 순서 지정 된 서비스 및 바구니 서비스입니다.

각 마이크로 서비스는 자체 데이터베이스를 다른 microservices에서 완전히 분리 될 수 있습니다. 필요한 경우 다른 microservices의 데이터베이스 간 일관성 응용 프로그램 수준 이벤트를 사용 하 여 이루어집니다. 자세한 내용은 참조 [Microservices 간의 통신](#communication_between_microservices)합니다.

참조 응용 프로그램에 대 한 자세한 내용은 참조 [.NET Microservices:.NET 응용 프로그램의 컨테이너 화 된 아키텍처](https://aka.ms/microservicesebook)합니다.

<a name="communication_between_client_and_microservices" />

## <a name="communication-between-client-and-microservices"></a>클라이언트와 Microservices 간의 통신

EShopOnContainers 모바일 앱에서 사용 하 여 컨테이너 화 된 백 엔드 microservices 통신할 *클라이언트 마이크로 서비스를 직접* 통신 그림 8-5에 표시 되어 있습니다.

![](containerized-microservices-images/directclienttomicroservicecommunication.png "Microservices 응용 프로그램 크기 조정 방식")

**그림 8-5**: 직접 클라이언트 마이크로 서비스 통신

직접 클라이언트 마이크로 서비스 통신으로 모바일 앱에서는 마이크로 서비스 마다 다른 TCP 포트는 공용 끝점을 통해 직접 각 마이크로 서비스를 요청 합니다. 프로덕션 환경에서 사용 가능한 인스턴스 요청을 분산 마이크로 서비스의 부하 분산을 끝점이 매핑합니다 일반적으로 합니다.

> [!TIP]
> API 게이트웨이 통신을 사용 하는 것이 좋습니다. 대규모 또는 복잡 한 마이크로 서비스를 구축 기반 응용 프로그램 상태 이지만 작은 응용 프로그램에 대 한 적절 한 개 이상의 직접 클라이언트 마이크로 서비스 통신 단점을 가질 수 있습니다. 큰 마이크로 서비스를 디자인 microservices 포함 응용 프로그램을 기반 하는 경우, API 게이트웨이 통신을 사용 하는 것이 좋습니다. 자세한 내용은 참조 [.NET Microservices:.NET 응용 프로그램의 컨테이너 화 된 아키텍처](https://aka.ms/microservicesebook)합니다.

<a name="communication_between_microservices" />

## <a name="communication-between-microservices"></a>Microservices 간의 통신

Microservices 기반 응용 프로그램은 잠재적으로 여러 컴퓨터에서 실행 되는 분산된 시스템을 합니다. 각 서비스 인스턴스는 일반적으로 프로세스입니다. 따라서 서비스는 HTTP, TCP, 고급 메시지 큐 프로토콜 AMQP (), 각 서비스의 성격에 따라 이진 프로토콜 등의 프로세스 간 통신 프로토콜을 사용 하 여 작용 해야 합니다.

마이크로 서비스 마이크로 서비스 통신에 대 한 두 가지 일반적인 방법은 데이터 및 업데이트 여러 microservices 간에 통신할 때 경량 비동기 메시징에 쿼리할 때 HTTP 기반 REST 통신 됩니다.

비동기 메시징 기반된 이벤트 기반 통신은 중요 한 여러 microservices에서 변경 내용을 전파 하는 경우입니다. 이 접근 방식는 마이크로 서비스 주목할 만한 일이 생기, 예를 들어 비즈니스 엔터티를 업데이트 하는 특정 상황이 발생할 때 이벤트를 게시 합니다. 다른 microservices 이러한 이벤트를 구독 합니다. 그런 다음는 마이크로 서비스는 이벤트를 받을 경우 자체 비즈니스 엔터티를 다시 게시 되 고 더 많은 이벤트가 발생할 수 있습니다를 업데이트 합니다. 이 게시-구독 기능 이벤트 버스와 함께 일반적으로 이루어집니다.

이벤트 버스 게시-구독 그림 8-6에 나와 있는 것 처럼, 명시적으로 인식 하는 구성 요소를 요구 하지 않고 microservices 간의 통신을 허용 합니다.

![](containerized-microservices-images/eventbus.png "이벤트 버스와 함께 게시-구독")

**그림 8-6:** 이벤트 버스와 함께 게시-구독

응용 프로그램 관점에서 이벤트 버스는 단순히 게시-구독 채널 인터페이스를 통해 노출 합니다. 그러나 이벤트 버스가 구현 되는 방식 달라질 수 있습니다. 예를 들어 RabbitMQ, Azure 서비스 버스 또는 NServiceBus MassTransit 등 다른 서비스 버스 이벤트 버스 구현을 사용할 수 있습니다. 그림 8-7 eShopOnContainers 참조 응용 프로그램에서 이벤트 버스가 사용 하는 방식을 보여 줍니다.

![](containerized-microservices-images/microservicesarchitecturewitheventbus.png "참조 응용 프로그램에서 이벤트 구동 비동기 통신")

**그림 8-7:** 참조 응용 프로그램에서 이벤트 구동 비동기 통신

RabbitMQ를 사용 하 여 구현 eShopOnContainers 이벤트 버스,-다 비동기 게시-구독 기능을 제공 합니다. 즉, 이벤트를 게시 한 후 있을 수 있는데 여러 구독자가 동일한 이벤트를 수신 대기 합니다. 그림 8-9이이 관계를 보여 줍니다.

![](containerized-microservices-images/eventdrivencommunication.png "1 대 다 통신")

**그림 8-9**: 대 다 통신

이벤트를 사용 하 여 서비스 간의 결과적 일관성을 보장 하는 여러 서비스에 걸쳐 있는 비즈니스 트랜잭션을 구현 하는 대 다 통신 이렇게 합니다. 결과적으로 일관 된 트랜잭션 일련의 분산된 단계로 이루어져 있습니다. 따라서 사용자 프로필 마이크로 서비스 하기 위한 명령을 받으면 해당 데이터베이스에 사용자의 세부 정보를 업데이트를 UserUpdated 이벤트를 이벤트 버스에 게시 합니다. 바구니 마이크로 서비스와 정렬 마이크로 서비스를이 이벤트를 받고 응답에서 각각의 데이터베이스에서 구매자 정보를 업데이트할 구독 합니다.

> [!NOTE]
> RabbitMQ를 사용 하 여 구현 eShopOnContainers 이벤트 버스, 개념 증명으로 사용 하는 데 사용 됩니다. 프로덕션 시스템에 대 한 대체 이벤트 버스 구현 고려 되어야 합니다.

이벤트 버스 구현에 대 한 정보를 참조 하십시오. [.NET Microservices:.NET 응용 프로그램의 컨테이너 화 된 아키텍처](https://aka.ms/microservicesebook)합니다.

## <a name="summary"></a>요약

Microservices 응용 프로그램 개발 및 배포 하는 최신 클라우드 응용 프로그램의 민첩성, 배율 및 안정성 요구 사항에 적합 한 방법을 제공 합니다. 있습니다 수 없게 된다는 확장 독립적으로 즉, 특정 기능 영역의 확장 수 있다는 불필요 하 게 영역을 크기 조정 없이 요청을 지원 하기 위해 더 많은 처리 전원 또는 네트워크 대역폭을 필요로 하는 microservices의 주요 이점 중 하나 늘어난된 수요에 발생 하는 응용 프로그램입니다.

컨테이너는 격리 된, 리소스 제어 되며 이식 가능한 운영 환경, 응용 프로그램 호스트 중 다른 컨테이너의 리소스를 건드리지 않고 간단히 실행할 수 있는 합니다. 기업 응용 프로그램 기반 마이크로 서비스를 구현 하 고 Docker 대부분 소프트웨어 플랫폼 및 클라우드 공급 업체에서 채택 하는 표준 컨테이너 구현 되었습니다 컨테이너를 채택 점점 더 됩니다.


## <a name="related-links"></a>관련 링크

- [EBook (2mb PDF)를 다운로드 합니다.](https://aka.ms/xamarinpatternsebook)
- [eShopOnContainers (GitHub) (샘플)](https://github.com/dotnet-architecture/eShopOnContainers)
