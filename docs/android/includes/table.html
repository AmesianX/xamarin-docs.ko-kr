<table width="100%" border="1px">
<tr>
    <td><b>속성</b></td>
    <td><b>설명</b></td>
    <td><b>옵션</b></td>
</tr>
<tr>
    <td><code> abi.type </code></td>
    <td><strong>ABI 형식</strong> – 에뮬레이트된 장치의 ABI(응용 프로그램 이진 인터페이스) 형식을 지정합니다. <code>x86</code> 옵션은 일반적으로 "x86" 또는 "IA-32"라고 하는 명령 집합용입니다. <code>x86_64</code> 옵션은 64비트 x86 명령 집합용입니다. <code>armeabi-v7a</code> 옵션은 v7-a ARM 확장이 있는 ARM 명령 집합용입니다. <code>arm64-v8a</code> 옵션은 AArch64를 지원하는 ARM 명령 집합용입니다.  </td>
    <td> x86, x86_64, armeabi-v7a, arm64-v8a </td>
</tr>
<tr>
    <td><code> disk.cachePartition </code></td>
    <td><strong>파티션 캐시</strong> – 에뮬레이트된 장치에서 장치에 대해 <strong>/cache</strong> 파티션을 사용할지 여부를 결정합니다. <strong>/cache</strong> 파티션(처음에는 비어 있음)은 Android에서 자주 액세스하는 데이터 및 앱 구성 요소를 저장하는 위치입니다. <code>no</code>로 설정하면 에뮬레이터에서 <strong>/cache</strong> 파티션을 사용하지 않고 다른 <code>disk.cache</code> 설정은 무시됩니다.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> disk.cachePartition.path </code></td>
    <td><strong>캐시 파티션 경로</strong> – 개발 컴퓨터의 캐시 파티션 이미지 파일을 지정합니다. 에뮬레이터에서 이 파일을 <strong>/cache</strong> 파티션에 사용합니다. 에뮬레이터의 <strong>data</strong> 디렉터리에 대한 절대 경로 또는 상대 경로를 입력합니다. 설정되지 않으면 에뮬레이터에서 <strong>cache.img</strong>라는 빈 임시 파일을 개발 컴퓨터에 만듭니다. 파일이 없으면 빈 파일로 만들어집니다. <code>disk.cachePartition</code>이 <code>no</code>로 설정되면 이 옵션은 무시됩니다. </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.cachePartition.size </code></td>
    <td><strong>캐시 파티션 크기</strong> – 캐시 파티션 파일의 크기(메가바이트 단위)입니다.. 앱에서 기본 캐시 크기인 66메가바이트를 초과하는 매우 큰 파일을 다운로드하지 않으면 이 옵션은 일반적으로 설정할 필요가 없습니다. <code>disk.cachePartition</code>이 <code>no</code>로 설정되면 이 옵션은 무시됩니다.</td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.dataPartition.initPath </code></td>
    <td><strong>데이터 파티션에 대한 초기 경로</strong> – 데이터 파티션의 초기 콘텐츠를 지정합니다. 사용자 데이터를 제거한 후에 에뮬레이터에서 <strong>userdata.img</strong>를 초기 버전으로 사용하는 대신 지정된 파일의 내용을 사용자 데이터(기본적으로 <strong>userdata-qemu.img</strong>)로 복사합니다. </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.dataPartition.path </code></td>
    <td><strong>데이터 파티션에 대한 경로</strong> – 사용자 데이터 파티션 파일을 지정합니다. 영구 사용자 데이터 파일을 구성하려면 개발 컴퓨터에 파일 이름과 경로를 입력합니다. 파일이 없으면 에뮬레이터에서 <strong>userdata.img</strong> 기본 파일로부터 이미지를 만들고, <code>disk.dataPartition.path</code>에 지정된 파일 이름으로 저장하고, 에뮬레이터가 종료될 때 사용자 데이터를 계속 유지합니다. 경로를 지정하지 않으면 기본 파일 이름은 <strong> userdata-qemu.img </strong>입니다. <code>&lt;temp></code> 특수 값을 사용하면 에뮬레이터에서 임시 파일을 만들고 사용할 수 있습니다. <code>disk.dataPartition.initPath</code>을 설정하면 부팅 시 해당 내용이 <code>disk.dataPartition.path</code> 파일에 복사됩니다. 이 옵션은 비워 둘 수 없습니다.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.dataPartition.size </code></td>
    <td><strong>데이터 파티션 크기</strong> – 사용자 데이터 파티션의 크기(메가바이트 단위)를 지정합니다.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.ramdisk.path </code></td>
    <td><strong>Ramdisk 경로</strong> – 부팅 파티션(Ramdisk) 이미지에 대한 경로입니다. Ramdisk 이미지는 시스템 이미지를 탑재하기 전에 커널에서 로드되는 시스템 이미지의 하위 집합입니다. Ramdisk 이미지에는 일반적으로 부팅 시 이진 파일 및 초기화 스크립트가 포함됩니다. 이 옵션을 지정하지 않으면 기본값은 에뮬레이터 시스템 디렉터리의 <strong>ramdisk.img</strong>입니다.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.snapStorage.path </code></td>
    <td><strong>스냅숏 저장소 경로</strong> – 모든 스냅숏이 저장되는 <i>스냅숏 저장소 파일</i>에 대한 경로입니다. 실행 중에 만든 스냅숏은 모두 이 파일에 저장됩니다. 에뮬레이터를 실행하는 동안 이 파일에 저장된 스냅숏만 복원할 수 있습니다. 이 옵션을 지정하지 않으면 기본값은 에뮬레이터 데이터 디렉터리의 <strong>snapshots.img</strong>입니다.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.systemPartition.initPath </code></td>
    <td><strong>시스템 파티션 초기화 경로</strong> – 시스템 이미지 파일의 읽기 전용 복사본에 대한 경로입니다. 특히 시스템 라이브러리와 API 수준 및 변형에 해당하는 데이터를 포함하는 파티션입니다. 이 경로를 지정하지 않으면 기본값은 에뮬레이터 시스템 디렉터리의 <strong>system.img</strong>입니다.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.systemPartition.path </code></td>
    <td><strong>시스템 파티션 경로</strong> – 읽기/쓰기 시스템 파티션 이미지에 대한 경로입니다. 이 경로를 설정하지 않으면 <code>disk.systemPartition.initPath</code>에 지정된 파일의 내용에서 임시 파일이 만들어지고 초기화됩니다. </td>
    <td>  </td>
</tr>
<tr>
    <td><code> disk.systemPartition.size </code></td>
    <td><strong>시스템 파티션 크기</strong> – 이상적인 시스템 파티션 크기(메가바이트 단위)입니다. 실제 시스템 파티션 이미지가 이 설정보다 크면 해당 크기가 무시됩니다. 그렇지 않으면 시스템 파티션 파일이 커질 수 있는 최대 크기를 지정합니다.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.accelerometer </code></td>
    <td><strong>가속도계</strong> – 에뮬레이트된 장치에 가속도계 센서가 포함되는지 여부를 결정합니다. 가속도계는 장치에서 방향을 결정하는 데 도움이 됩니다(자동 회전에 사용됨). 가속도계는 3개의 센서 축을 따라 장치의 가속도를 보고합니다.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.audioInput </code></td>
    <td><strong>오디오 녹음 지원</strong> – 에뮬레이트된 장치에서 오디오를 녹음할 수 있는지 여부를 결정합니다.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.audioOutput </code></td>
    <td><strong>오디오 재생 지원</strong> – 에뮬레이트된 장치에서 오디오를 재생할 수 있는지 여부를 결정합니다.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.battery </code></td>
    <td><strong>배터리 지원</strong> – 에뮬레이트된 장치가 배터리에서 실행될 수 있는지 여부를 결정합니다.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.camera </code></td>
    <td><strong>카메라 지원</strong> – 에뮬레이트된 장치에 카메라가 있는지 여부를 결정합니다.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.camera.back </code></td>
    <td><strong>후면 카메라</strong> – 후면 카메라(렌즈가 사용자 반대쪽으로 향함)를 구성합니다. 개발 컴퓨터에서 웹캠을 사용하여 에뮬레이트된 장치에서 후면 카메라를 시뮬레이션하는 경우 이 값은 <code>webcam<i>n</i></code>으로 설정해야 합니다. 여기서 <i>n</i>은 웹캠을 선택합니다(웹캠 하나만 있는 경우 <code>webcam0</code> 선택). <code>emulated</code>로 설정하면 에뮬레이터가 소프트웨어에서 카메라를 시뮬레이션합니다. 후면 카메라를 사용하지 않도록 설정하려면 이 값을 <code>none</code>으로 설정합니다. 후면 카메라를 사용하도록 설정하면 <code>hw.camera</code>도 활성화해야 합니다.  </td>
    <td> emulated, none, webcam0 </td>
</tr>
<tr>
    <td><code> hw.camera.front </code></td>
    <td><strong>전면 카메라</strong> – 전면 카메라(렌즈가 사용자쪽으로 향함)를 구성합니다. 개발 컴퓨터에서 웹캠을 사용하여 에뮬레이트된 장치에서 전면 카메라를 시뮬레이션하는 경우 이 값은 <code>webcam<i>n</i></code>으로 설정해야 합니다. 여기서 <i>n</i>은 웹캠을 선택합니다(웹캠 하나만 있는 경우 <code>webcam0</code> 선택). <code>emulated</code>로 설정하면 에뮬레이터가 소프트웨어에서 카메라를 시뮬레이션합니다. 전면 카메라를 사용하지 않도록 설정하려면 이 값을 <code>none</code>으로 설정합니다. 전면 카메라를 사용하도록 설정하면 <code>hw.camera</code>도 활성화해야 합니다.  </td>
    <td> emulated, none, webcam0 </td>
</tr>
<tr>
    <td><code> hw.camera.maxHorizontalPixels </code></td>
    <td><strong>최대 가로 카메라 픽셀</strong> – 에뮬레이트된 장치의 카메라에 대한 최대 가로 해상도(픽셀 단위)를 구성합니다.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.camera.maxVerticalPixels </code></td>
    <td><strong>최대 세로 카메라 픽셀</strong> – 에뮬레이트된 장치의 카메라에 대한 최대 세로 해상도(픽셀 단위)를 구성합니다.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.cpu.arch </code></td>
    <td><strong>CPU 아키텍처</strong> – 가상 장치에서 에뮬레이트할 CPU 아키텍처입니다. 하드웨어 가속을 위해 Intel HAXM을 사용하는 경우 32비트 CPU에 대해 <code>x86</code>을 선택합니다. 64비트 HAXM 가속 장치의 경우 <code>x86_64</code>를 선택합니다. (SDK 관리자에서 해당 Intel x86 시스템 이미지(예: <strong>Intel x86 Atom</strong> 또는 <strong>Intel x86 Atom_64</strong>)를 설치해야 합니다.) ARM CPU를 시뮬레이션하려면 32비트에 대해 <code>arm</code>을 선택하거나 64비트 ARM CPU에 대해 <code>arm64</code>를 선택합니다. ARM 기반 가상 장치는 ARM에서 하드웨어 가속을 사용할 수 없으므로 x86 기반 가상 장치보다 훨씬 느리게 실행됩니다.  </td>
    <td> x86, x86_64, arm, arm64 </td>
</tr>
<tr>
    <td><code> hw.cpu.model </code></td>
    <td><strong>CPU 모델</strong> – 이 값은 일반적으로 설정되지 않은 상태로 유지됩니다(아직 명시적으로 설정되지 않은 경우 <code>hw.cpu.arch</code>에서 파생된 값으로 설정됨). 그러나 실험적 용도로 에뮬레이터 특정 문자열로 설정할 수 있습니다.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.dPad </code></td>
    <td><strong>DPad 키</strong> – 에뮬레이트된 장치에서 방향 패드(DPad) 키를 지원하는지 여부를 결정합니다. DPad에는 일반적으로 방향 제어를 나타내는 4개의 키가 있습니다.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.gps </code></td>
    <td><strong>GPS 지원</strong> – 에뮬레이트된 장치에 GPS(글로벌 위치 시스템) 수신기가 있는지 여부를 결정합니다.  </td>
    <td> yes, no </td>
<tr>
</tr>
<tr>
    <td><code> hw.gpu.enabled </code></td>
    <td><strong>GPU 에뮬레이션</strong> – 에뮬레이트된 장치에서 GPU 에뮬레이션을 지원하는지 여부를 결정합니다. 사용하도록 설정되면 GPU 에뮬레이션에서 2D 및 3D 그래픽 모두를 화면에 렌더링하기 위해 OpenGL ES(Open GL for Embedded Systems)를 사용하며, 관련 GPU 에뮬레이션 모드 설정은 GPU 에뮬레이션을 구현하는 방법을 결정합니다.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.gpu.mode </code></td>
    <td><strong>GPU 에뮬레이션 모드</strong> – 에뮬레이터에서 GPU 에뮬레이션을 구현하는 방법을 결정합니다. <code>auto</code>를 선택하면 에뮬레이터에서 개발 컴퓨터 설정에 따라 하드웨어 가속 및 소프트웨어 가속을 선택합니다. <code>host</code>를 선택하면 에뮬레이터에서 개발 컴퓨터의 그래픽 프로세서를 사용하여 더 빠른 렌더링을 위한 GPU 에뮬레이션을 수행합니다. GPU가 에뮬레이터와 호환되지 않고 Windows를 사용하는 경우 <code>host</code> 대신 <code>angle</code>을 시도할 수 있습니다. <code>angle</code> 모드는 DirectX를 사용하여 <code>host</code>와 비슷한 성능을 제공합니다. <code>mesa</code>를 선택하면 에뮬레이터에서 Mesa 3D 소프트웨어 라이브러리를 사용하여 그래픽을 렌더링합니다. 개발 컴퓨터의 그래픽 프로세서를 통해 렌더링하는 데 문제가 있으면 <code>mesa</code>를 선택합니다. <code>swiftshader</code> 모드는 컴퓨터의 GPU를 사용하는 것보다 약간 낮은 성능으로 소프트웨어에서 그래픽을 렌더링하는 데 사용할 수 있습니다. 사용되지 않는 <code>off</code> 옵션(그래픽 하드웨어 에뮬레이션 사용 안 함)은 일부 항목에 대해 부적절한 렌더링이 발생할 수 있으므로 사용하지 않는 것이 좋습니다. </td>
    <td> auto, host, mesa, angle, swiftshader, off </td>
</tr>
<tr>
    <td><code> hw.gsmModem </code></td>
    <td><strong>GSM 모뎀 지원</strong> – 에뮬레이트된 장치에 GSM(이동 통신 글로벌 시스템) 전화 통신 무선 시스템을 지원하는 모뎀이 포함되는지 여부를 결정합니다.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.initialOrientation </code></td>
    <td><strong>초기 화면 방향</strong> – 에뮬레이트된 장치에 대한 화면의 초기 방향(세로 또는 가로 모드)을 구성합니다. 세로 모드에서는 화면의 높이가 너비보다 큽니다. 가로 모드에서는 화면의 너비가 높이보다 큽니다. 장치 프로필에서 세로 및 가로 모드 모두를 지원하는 경우 에뮬레이트된 장치를 실행할 때 방향을 변경할 수 있습니다.  </td>
    <td> portrait, landscape </td>
</tr>
<tr>
    <td><code> hw.keyboard </code></td>
    <td><strong>키보드 지원</strong> – 에뮬레이트된 장치에서 QWERTY 키보드를 지원하는지 여부를 결정합니다.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.keyboard.charmap </code></td>
    <td><strong>키보드 문자표 이름</strong> – 이 장치에 대한 하드웨어 문자표의 이름입니다. 참고: 시스템 이미지를 적절하게 수정하지 않는 한 항상 기본값(<code>qwerty2</code>)이어야 합니다. 이 이름은 부팅 시 커널에 보내집니다. 잘못된 이름을 사용하면 사용할 수 없는 가상 장치가 됩니다.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.keyboard.lid </code></td>
    <td><strong>키보드 덮개 지원</strong> – 키보드 지원을 사용하도록 설정된 경우 이 설정은 QWERTY 키보드를 닫거나 숨길 수 있는지, 아니면 열거나 표시할 수 있는지 여부를 결정합니다. <code>hw.keyboard</code>가 <code>false</code>로 설정되면 이 설정은 무시됩니다. 참고: 에뮬레이트된 장치에서 API 수준 12 이상을 대상으로 하는 경우 기본값은 <code>false</code>입니다.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.lcd.backlight </code></td>
    <td><strong>LCD 후광</strong> – 에뮬레이트된 장치에서 LCD 후광을 시뮬레이션할지 여부를 결정합니다.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.lcd.density </code></td>
    <td><strong>LCD 밀도</strong> – 에뮬레이트된 LCD 디스플레이의 밀도이며, 밀도 독립적 픽셀 또는 <i>dp</i>(가상 픽셀 단위)로 측정된 것입니다. 설정이 160dp이면 각 dp가 하나의 물리적 픽셀에 해당합니다. 런타임에 Android에서 이 값을 사용하여 올바른 디스플레이 렌더링에 적절한 리소스/자산을 선택하고 크기를 조정합니다.  </td>
    <td> 120, 160, 240, 213, 320 </td>
</tr>
<tr>
    <td><code> hw.lcd.depth </code></td>
    <td><strong>LCD 색 농도</strong> – LCD 디스플레이를 구동하기 위한 비트맵을 보유하는 에뮬레이트된 프레임 버퍼의 색 비트 농도입니다. 이 값은 16비트(65,536개 색 가능) 또는 32비트(16,777,216개 색 + 투명도)일 수 있습니다. 32비트로 설정하면 에뮬레이터가 약간 느리게 실행되지만 색 정확도가 향상됩니다.  </td>
    <td> 16, 32 </td>
</tr>
<tr>
    <td><code> hw.lcd.height </code></td>
    <td><strong>LCD 픽셀 높이</strong> – 에뮬레이트된 LCD 디스플레이의 수직 크기를 구성하는 픽셀 수입니다.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.lcd.width </code></td>
    <td><strong>LCD 픽셀 너비</strong> – 에뮬레이트된 LCD 디스플레이의 수평 크기를 구성하는 픽셀 수입니다.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.mainKeys </code></td>
    <td><strong>하드웨어 뒤로/홈 키</strong> – 에뮬레이트된 장치에서 하드웨어 뒤로 및 홈 탐색 단추를 지원하는지 여부를 결정합니다. 소프트웨어에서만 단추를 구현하더라도 이 값은 <code>yes</code>로 설정할 수 있습니다. <code>hw.mainKeys</code>가 <code>yes</code>로 설정되면 에뮬레이터에서 화면에 탐색 단추를 표시하지 않지만 에뮬레이터 측면 패널을 사용하여 이러한 단추를 "누를" 수 있습니다.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.ramSize </code></td>
    <td><strong>장치 RAM 크기</strong> – 에뮬레이트된 장치의 실제 RAM 크기(메가바이트 단위)입니다. 기본값은 화면 크기 또는 스킨 버전에서 계산됩니다. 크기를 늘리면 에뮬레이터의 작동 속도가 빨라지지만 개발 컴퓨터에서 더 많은 리소스가 필요합니다.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.screen </code></td>
    <td><strong>터치 스크린 형식</strong> – 에뮬레이트된 장치의 화면 형식을 정의합니다. <code>multi-touch</code> 화면은 터치 인터페이스에서 둘 이상의 손가락을 추적할 수 있습니다. <code>touch</code> 화면은 하나의 손가락 터치 이벤트만 감지할 수 있습니다. <code>no-touch</code> 화면은 터치 이벤트를 감지하지 않습니다.  </td>
    <td> touch, multi-touch, no-touch </td>
</tr>
<tr>
    <td><code> hw.sdCard </code></td>
    <td><strong>SD 카드 지원</strong> – 에뮬레이트된 장치에서 가상 SD(Secure Digital) 카드의 삽입 및 제거를 지원하는지 여부를 결정합니다. 에뮬레이터는 개발 컴퓨터에 저장된 탑재 가능한 디스크 이미지를 사용하여 실제 SD 카드 장치의 파티션을 시뮬레이션합니다(<code>hw.sdCard.path</code> 참조).  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> sdcard.size </code></td>
    <td><strong>SD 카드 크기</strong> – 장치에서 사용할 수 있고 <code>hw.sdCard.path</code>에 지정된 위치에 있는 가상 SD 카드 파일의 크기(바이트 단위)를 지정합니다. 크기가 단순 정수이면 크기를 바이트 단위로 지정합니다. 크기에 K, M 또는 G를 추가하여 크기를 킬로바이트, 메가바이트 및 기가바이트 단위로 지정할 수도 있습니다. 최소 크기는 9M이고 ,최대 크기는 1,023G입니다.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.sdCard.path </code></td>
    <td><strong>SD 카드 이미지 경로</strong> – 개발 컴퓨터에 있는 SD 카드 파티션 이미지 파일에 대한 파일 이름과 경로를 지정합니다. 예를 들어 이 경로는 Windows에서 <strong>C:\sd\sdcard.img</strong>로 설정할 수 있습니다.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> hw.sensors.magnetic_field </code></td>
    <td><strong>자기장 센서</strong> – 에뮬레이트된 장치에서 자기장 센서를 지원하는지 여부를 결정합니다. 자기장 센서(자기계라고도 함)는 3개의 센서 축을 따라 측정된 주위 지자기장을 보고합니다. 컴퍼스 읽기에 액세스해야 하는 앱의 경우 이 설정을 사용하도록 설정합니다. 예를 들어 내비게이션 앱은 이 센서를 사용하여 사용자가 지향하는 방향을 감지할 수 있습니다.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.sensors.orientation </code></td>
    <td><strong>방향 센서</strong> – 에뮬레이트된 장치에서 방향 센서 값을 제공하는지 여부를 결정합니다. 방향 센서는 3개의 모든 물리적 축(x, y, z)을 중심으로 장치가 회전하는 각도를 측정합니다. Android 2.2(API 수준 8)부터는 방향 센서가 지원되지 않습니다.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.sensors.proximity </code></td>
    <td><strong>근접 센서</strong> – 에뮬레이트된 장치에서 근접 센서를 지원하는지 여부를 결정합니다. 이 센서는 개체의 근접 거리를 장치의 보기 화면을 기준으로 측정합니다. 일반적으로 송수화기를 사람의 귀에 대고 있는지 여부를 확인하는 데 사용됩니다.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.sensors.temperature </code></td>
    <td><strong>온도 센서</strong> – 에뮬레이트된 장치에서 온도 센서를 지원하는지 여부를 결정합니다. 이 센서는 장치의 온도를 섭씨 온도(°C)로 측정합니다.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.touchScreen </code></td>
    <td><strong>터치 스크린 지원</strong> – 에뮬레이트된 장치에서 터치 스크린을 지원하는지 여부를 결정합니다. 터치 스크린은 화면에서 개체를 직접 조작하는 데 사용됩니다.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.trackBall </code></td>
    <td><strong>트랙볼 지원</strong> – 에뮬레이트된 장치에서 트랙볼을 지원하는지 여부를 결정합니다.  </td>
    <td> yes, no </td>
</tr>
<tr>
    <td><code> hw.useext4 </code></td>
    <td><strong>EXT4 파일 시스템 지원</strong> – 에뮬레이트된 장치에서 파티션에 대해 Linux EXT4 파일 시스템을 사용하는지 여부를 결정합니다. 이제 파일 시스템 형식이 자동으로 감지되므로 이 옵션은 더 이상 사용되지 않으며 무시됩니다.  </td>
    <td> 아니요 </td>
</tr>
<tr>
    <td><code> kernel.newDeviceNaming </code></td>
    <td><strong>커널 새 장치 이름 지정</strong> – 커널에 새 장치 이름 지정 체계가 필요한지 여부를 지정하는 데 사용됩니다. 일반적으로 Linux 3.10 커널 이상에서 사용됩니다. <code>autodetect</code>로 설정하면 에뮬레이터에서 커널에 새 장치 이름 지정 체계가 필요한지 여부를 자동으로 감지합니다.  </td>
    <td> autodetect, yes, no </td>
</tr>
<tr>
    <td><code> kernel.parameters </code></td>
    <td><strong>커널 매개 변수</strong> – Linux 커널 부팅 매개 변수의 문자열을 지정합니다. 이 설정은 기본적으로 비워 둡니다.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> kernel.path </code></td>
    <td><strong>커널 경로</strong> – Linux 커널에 대한 경로를 지정합니다. 이 경로를 지정하지 않으면 에뮬레이터에서 에뮬레이터 시스템 디렉터리의 <code>kernel-ranchu</code>를 찾습니다.  </td>
    <td>  </td>
</tr>
<tr>
    <td><code> kernel.supportsYaffs2 </code></td>
    <td><strong>YAFFS2 파티션 지원</strong> – 커널에서 YAFFS2(Yet Another Flash File System 2) 파티션을 지원하는지 여부를 결정합니다. 일반적으로 Linux 3.10 이전의 커널에만 적용됩니다. <code>autodetect</code>로 설정하면 에뮬레이터에서 커널이 YAFFS2 파일 시스템을 탑재할 수 있는지 여부를 자동으로 감지합니다.  </td>
    <td> autodetect, yes, no </td>
</tr>
<tr>
    <td><code> skin.name </code></td>
    <td><strong>스킨 이름</strong> – Android 에뮬레이터 스킨에 대한 이름입니다. 스킨은 에뮬레이터 디스플레이의 시각적 개체 요소 및 컨트롤 요소를 정의하는 파일의 모음입니다. 개발 컴퓨터에 표시되는 AVD 창의 모양을 설명합니다. 스킨은 화면 크기, 단추 및 전체 디자인을 설명하지만 앱 작동에는 영향을 주지 않습니다. </td>
    <td> </td>
</tr>
<tr>
    <td><code> skin.path </code></td>
    <td><strong>스킨 경로</strong> – <code>skin.name</code>에 지정된 에뮬레이터 스킨 파일이 포함된 디렉터리에 대한 경로입니다. 이 디렉터리에는 <code>hardware.ini</code> 레이아웃 파일 및 스킨의 표시 요소에 대한 이미지 파일이 포함되어 있습니다. </td>
    <td> </td>
</tr>
<tr>
    <td><code> skin.dynamic </code></td>
    <td><strong>동적 스킨</strong> – 동적 스킨인지의 여부입니다. 에뮬레이터에서 지정된 너비와 높이에 따라 지정된 크기의 스킨을 생성하는 경우 에뮬레이터 스킨은 동적 스킨입니다. </td>
    <td> 아니요 </td>
</tr>
</table>
