---
title: Xamarin.iOS에서.xib 코드 생성
description: 이 문서에서는 Xamarin.iOS 시각적 컨트롤을 프로그래밍 방식으로 액세스할 수 있도록 C# 맵.xib 파일에 코드를 생성 하는 방법을 설명 합니다.
ms.prod: xamarin
ms.assetid: 365991A8-E07A-0420-D28E-BC4D32065E1A
ms.technology: xamarin-ios
author: bradumbaugh
ms.author: brumbaug
ms.date: 03/21/2017
ms.openlocfilehash: 064e17393747a36cd761cb2464e3239cfc17141c
ms.sourcegitcommit: ea1dc12a3c2d7322f234997daacbfdb6ad542507
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 06/05/2018
ms.locfileid: "34786150"
---
# <a name="xib-code-generation-in-xamarinios"></a>Xamarin.iOS에서.xib 코드 생성

> [!IMPORTANT]
>  이 문서에서는 Mac의 Xcode의 인터페이스 작성기만을 통합 하기 위해 Visual Studio 설명 동작과 콘센트에에서 사용 되지 않는 Xamarin 디자이너 iOS 용으로 합니다. IOS 디자이너에서 자세한 정보를 검토 하십시오는 [iOS 디자이너](~/ios/user-interface/designer/index.md) 문서.

사용자 인터페이스를 시각적으로 디자인 하는 Apple 인터페이스 작성기 도구 ("IB")를 사용할 수 있습니다. IB가 만든 인터페이스 정의에 저장 됩니다 **.xib** 파일입니다. 위젯 및 기타 개체에 **.xib** "클래스 id가" 사용자 지정 사용자 정의 형식이 될 수 있는 파일을 지정할 수 있습니다. 이렇게 하면 위젯이 동작을 사용자 지정 하 고 사용자 지정 도구를 작성할 수 있습니다.

이러한 사용자 클래스는 일반적으로 UI 컨트롤러 클래스의 서브 클래스입니다. 서로 *콘센트* (속성과 유사) 및 *동작* (이벤트 비슷) 인터페이스 개체에 연결할 수 있습니다. 런타임 시 IB 파일이 로드 된 개체 생성 되 고 작업과 콘센트 동적으로 다양 한 UI 개체에 연결 되어 있습니다. 이러한 관리 되는 클래스를 정의할 때 모든 동작 및 콘센트에 IB 필요한 프로필과 일치 하도록 정의 해야 합니다. Mac 용 visual Studio는이 간소화 하기 위해 코드 숨김와 같은 모델을 사용 합니다. 이 Objective C 용 Xcode 수행 하는 작업 유사 하지만 코드 생성 모델 및 규칙.NET 개발자에 게 더 쉽게 수정 된 있어야 합니다.

작업할 **.xib** 파일은 현재 지원 되지 않습니다 Xamarin.iOS에서 Visual Studio에 대 한 합니다.

## <a name="xib-files-and-custom-classes"></a>.xib 파일 및 사용자 지정 클래스

Cocoa 터치 기존 형식을 사용 하 여, 뿐만 아니라 사용자 지정 형식에 정의할 수는 **.xib** 파일입니다. 다른 정의 된 형식을 사용 하 여 이기도 **.xib** 파일 또는 C# 코드에서 순수 하 게 정의 합니다. 인터페이스 작성기 외부에서 현재 정의 된 형식의 세부 정보를 인식 하지 않으므로 현재 **.xib** 파일 이기 때문에 나열 되거나 해당 사용자 지정 콘센트 및 작업에 표시 되지 것입니다. 오늘과에 예정 되어이 제한을 제거 합니다.

사용자 지정 클래스에서 정의할 수 있습니다는 **.xib** 인터페이스 작성기의 "클래스" 탭에서 "추가 하위 클래스" 명령을 사용 하 여 파일입니다. 우리는이 방법으로 "코드 숨김" 클래스를 참조 하십시오. 경우는 **.xib** 파일에는 ". xib.designer.cs" Mac에 대 한 다음 Visual Studio 프로젝트에서 테이블에 해당 파일은 자동으로 채울에 있는 모든 사용자 지정 클래스에 대 한 partial 클래스 정의 **.xib**합니다. "디자이너 클래스는"으로 이러한 부분 클래스 이라고합니다.

## <a name="generating-code"></a>코드 생성

에 대 한  **{0}.xib** 파일 빌드 작업으로 *페이지*경우는  **{0}. xib.designer.cs** 파일이 Mac 용 Visual Studio 프로젝트에도 있습니다. 찾을 수 있는 모든 사용자 클래스에 대 한 디자이너 파일에서 partial 클래스를 생성할는 **.xib** 콘센트가 대 한 속성 및 모든 작업에 대 한 부분 메서드와 함께 파일입니다. 이 파일의 존재 하 여 코드 생성이 사용 됩니다.

디자이너 파일은 자동으로 업데이트 될 때는 **.xib** Mac 유실 포커스에 대 한 파일 변경 내용 및 Visual Studio입니다. 변경 내용이 됩니다 Mac 업데이트에 대 한 다음 덮어쓸된 때 Visual Studio 파일 에서도 디자이너 파일을 수동으로 수정 하지 해야 합니다.

## <a name="registration-and-namespaces"></a>등록 및 네임 스페이스

Mac 용 visual Studio 디자이너 파일 위치에 대 한 프로젝트의 기본 네임 스페이스를 사용 하 여 기본.NET 프로젝트 namespacing 부분과 일치 하는 디자이너 클래스를 생성 합니다. 디자이너 파일의 네임 스페이스는 프로젝트의 "기본 네임 스페이스" 및 ".NET 이름 지정 정책" 설정에 의해 이루어집니다. 프로젝트의 기본 네임 스페이스가 변경 되 면 MD가 다시 생성 됩니다 새 네임 스페이스의 클래스를 partial 클래스 더 이상 일치 하는지 찾을 수 있도록에 주의 하세요.

Objective C 런타임에서 클래스 검색 가능 하 게, Mac 용 Visual Studio가 적용 되는 `[Register (name)]` 특성을 클래스입니다. Xamarin.iOS을 자동으로 등록 하지만 `NSObject`-파생 된 클래스를.NET 정규화 된 이름을 사용 합니다. 각 클래스를 확인 하려면이 옵션을 재정의 하는 Mac에 대 한 Visual Studio에 의해 적용 된 특성에 사용 되는 이름에 등록 되어는 **.xib** 파일입니다. Mac 용 Visual Studio를 사용 하 여 디자이너 파일을 생성 하지 않고 IB의 사용자 지정 클래스를 사용 하는 경우 예상된 Objective-c 클래스 이름에 일치 하 여 관리 되는 클래스를 확인 하려면 수동으로이 적용 할 수 있습니다.

둘 이상의에 클래스를 정의할 수 없습니다 **.xib**, 또는 충돌 합니다.

## <a name="non-designer-class-parts"></a>비 디자이너 클래스 부분

Partial 클래스 디자이너는으로 사용할 수 없습니다-됩니다. 콘센트는 private 이며 없는 기본 클래스를 지정 합니다. 각 클래스는 해당 "비 디자이너" 클래스 부분에에서 있는 다른 파일을 표시 하는 클래스를 기본 설정, 사용 하 여 또는 예로 로드할때네이티브코드에서클래스를인스턴스화하는데필요한생성자를정의것으로예상 **.xib**합니다. 기본 **.xib** 템플릿이 작업을 수행 하지만에서 정의 하는 추가 사용자 지정 클래스는 **.xib**, 비 디자이너 부분을 수동으로 추가 해야 합니다.

이유는 유연성을 위해 필요 합니다. 예를 들어 여러 코드 숨김 클래스 하위 클래스는 공통 관리 되는 추상 클래스는 서브 클래스는 클래스 IB 여 서브클래싱 할 수 있습니다.

규칙에 따른 이러한에 저장 하는 한  **{0}. xib.cs** 옆에 있는 파일의  **{0}. xib.designer.cs** 디자이너 파일입니다.

<a name="generated" />

## <a name="generated-actions-and-outlets"></a>발생된 한 동작 및 콘센트

부분 디자이너 클래스 Mac 용 Visual Studio IB, 및 연결 된 모든 작업에 해당 하는 부분 메서드에 정의 된 모든 연결 된 콘센트에 해당 속성을 생성 합니다.

### <a name="outlet-properties"></a>콘센트 속성

해당 사용자 지정 클래스에 정의 된 모든 콘센트 하는 속성을 포함 하는 디자이너 클래스 합니다. 다음은 속성 점은 지연 바인딩을 사용할 수 있도록 Objective C 브리지에 Xamarin.iOS의 구현 정보입니다. 코드 숨김 클래스를 통해서만 사용 하도록 하는 전용 필드에 해당 하는 수를 고려해 야 합니다. 공용 하려는 경우에 다른 전용 필드에 대해서와 마찬가지로 접근자 속성 비 디자이너 클래스 부분에 추가 합니다.

콘센트 속성의 형식을 갖도록 정의 된 경우 `id` (같음 `NSObject`) 디자이너 코드 생성기는 현재 편의 위해 해당 콘센트에 연결 하는 개체를 기반으로 가장 강력한 가능한 유형을 결정 합니다.
그러나이 하지 못할 이후 버전에서는 사용자 지정 클래스를 정의할 때 콘센트가 명시적으로 강력 하 게 입력 하는 것이 좋습니다.

### <a name="action-properties"></a>작업 속성

디자이너 클래스는 사용자 지정 클래스에 정의 된 모든 작업에 해당 하는 부분 메서드를 포함 합니다. 메서드는 구현 없이 이들은입니다. 부분 메서드에 목적은 다음과 같이 두 가지입니다.

1.  입력 하는 경우 `partial` 디자이너 비 클래스 부분 클래스 본문에 Mac 용 Visual Studio를 하는 옵션이 자동 완성 모든 비 구현 부분 메서드 서명입니다.
2.  부분 메서드 시그니처 있어야 하므로 해당 작업으로 처리 얻을 수 있습니다 Objective-c 외부에 노출 하는 특성이 적용.


원할 경우 부분 메서드 무시 될 수 있습니다 및 다른 메서드에 특성을 적용 하 여 작업을 구현 하거나 기본 클래스에 진행 되기를 기다립니다.

작업의 보낸 사람 형식을 갖도록 정의 된 경우 `id` (같음 `NSObject`), 디자이너 코드 생성기는 현재 해당 작업에 연결 된 개체를 기반으로 가장 강력한 가능한 유형을 결정 합니다. 그러나이 하지 못할 이후 버전에서는 사용자 지정 클래스를 정의할 때 동작을 명시적으로 강력 하 게 입력 하는 것이 좋습니다.

참고 다른 언어에 대해 생성 되지 않은 하므로 CodeDOM 부분 메서드를 지원 하지 않으므로 이러한 부분 메서드에 대해서만 C#의 경우 생성 됩니다.

## <a name="cross-xib-class-usage"></a>교차 XIB 클래스 사용

사용자가 다중에서 같은 클래스를 참조 하려고 하는 경우에 따라 **.xib** 탭 컨트롤러와 같은 파일입니다. 명시적으로 다른 클래스 정의 참조 하 여이 작업을 수행할 수 있습니다 **.xib** 파일 또는 여 클래스 이름이 같은 두 번째에 다시 정의 **.xib**합니다.

후자의 경우 Mac 처리를 위해 Visual Studio 하므로 문제가 될 수 **.xib** 파일을 개별적으로 합니다. 자동으로 검색 및 충돌 같은 partial 클래스 디자이너는 여러 파일에 정의 된 경우 등록 특성을 여러 번 적용 될 수 있습니다 하므로 중복 정의 병합 없습니다. Mac 용 Visual Studio의 최신 버전에서이 해결 하려고 하지만 항상 작동 하지 않을 예상 대로. 나중에이 지원 되지 않음, 되는 경우가 있으며 대신 Mac 용 Visual Studio를 통해 모든 페이지에서 정의 된 모든 형식을 **.xib** 파일과 관리 코드에 직접 표시 된 모든 프로젝트 **.xib** 파일입니다.

## <a name="type-resolution"></a>형식 확인

IB에 사용 된 유형은 Objective C 형식 이름입니다. 이러한 레지스터 특성을 사용 하 여 CLR 형식에 매핑됩니다. 소켓과 작업 코드를 생성할 때 Visual Studio Mac 용 Xamarin.iOS 코어에 의해 래핑된 모든 Objective-c 유형에 대 한 해당 CLR 형식을 확인를 업데이트 하 고 해당 형식 이름을 정규화 됩니다.

그러나 코드 생성기 하므로 이러한 경우에 형식 이름을 정확 하 게 출력에 현재 사용자 코드 또는 라이브러리에서 형식 이름 Objective C에서에서 CLR 유형을 확인할 수 없습니다. 즉, 해당 하는 CLR 형식은 Objective-c 유형 이름이 동일한 하며를 사용 하는 코드와 동일한 네임 스페이스에. 이 코드 생성 중 프로젝트에 있는 모든 Objective C 형식을 고려 하 여 나중에 잠시 해결 될 예정입니다.
